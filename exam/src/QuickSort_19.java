public class QuickSort_19 {

    /**
     * Основной метод для запуска быстрой сортировки
     * @param arr массив для сортировки
     */
    public static void quickSort(int[] arr) {

        // проверяем, что массив не пустой в нем в нем больше одного элемента
        if (arr == null || arr.length < 2) {
            return; // массив уже отсортирован
        }

        // запускаем рекурсивную сортировку для всего массива
        quickSort(arr, 0, arr.length - 1);
    }


    /**
     * Рекурсивный метод быстрой сортировки.
     * Сортирует подмассив от индекса left до right включительно.
     * @param arr массив для сортировки
     * @param left левый индекс текущего подмассива
     * @param right правый индекс текущего подмассива
     */
    private static void quickSort(int[] arr, int left, int right) {

        // подмассив состоит из 0 или 1 элемента
        if (left >= right) {
            return;
        }

        // Шаг 1. выбираем опорный элемент и делаем разбиение
        int pivotIndex = partition(arr, left, right);

        // Шаг 2. рекурсивно сортируем левую часть массива (до опорного элемента)
        quickSort(arr, left, pivotIndex - 1);

        // Шаг 3. рекурсивно сортируем правую часть массива (до опорного элемента)
        quickSort(arr, pivotIndex + 1, right);
    }


    /**
     * Перемещает элементы так, чтобы все элементы меньше опорного оказались слева,
     * а больше или равные – справа.
     * Возвращает финальный индекс опорного элемента
     * @param arr массив разбиения
     * @param left левый индекс подмассива
     * @param right правый индекс подмассива
     * @return индекс опорного элемента после разбиения
     */
    public static int partition(int[] arr, int left, int right) {

        // Выбираем опорный элемент. Часто берут последний элемент подмассива
        int pivot = arr[right];

        // Индекс для перемещения элементов меньше опорного
        int i = left - 1;

        // Проходим по всем элементам от left до right - 1
        for (int j = left; j < right; j++) {
            // Если текущий элемент меньшего опорного,
            // то увеличиваем i и меняем arr[i] и arr[j] местами,
            // чтобы элементы меньше опорного скапливались слева
            if (arr[j] < pivot) {
                i++; // сдвигаем индекс вправо
                swap(arr, i, j);
            }
        }

        // После того, как все меньшие элементы "собраны" слева,
        // ставим опорный элемент на место i + 1, чтобы он был между меньшими и большими элементами
        swap(arr, i + 1, right);

        // возвращаем индекс опорного элемента, теперь он "на своем месте"
        return i + 1;
    }

    /**
     * Вспомогательный метод для обмена элементов массива
     * @param arr массив
     * @param i индекс первого элемента
     * @param j индекс второго элемента
     */
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }


    public static void main(String[] args) {
        int[] arr = {9, 4, 6, 2, 7, 5, 1, 8, 3};

        System.out.println("Исходный массив:");
        Sorting_12.printArray(arr);

        quickSort(arr);

        System.out.println("Отсортированный массив:");
        Sorting_12.printArray(arr);
    }
}
